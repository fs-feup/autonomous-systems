# C/C++ and Python Basics

C is the mother of all languages. Almost any other language currently widely used has been built on top of C. C++ is but an extension of C for Object Oriented Programming.


## Installation

Python3 already comes default with Ubuntu. G++ can be installed through ```sudo apt install build-essential```. However, all of these dependencies are resolved by the previous tutorials.

## Compiling and Running Programs

While python uses an interpreter, which reads the program line by line and executes the code as it goes, C++ is a compiled language, meaning the code is first fully translated into binary code, and only then it is ready for execution.

### Python

In python, no build systems are necessary. Only run ```python <script.py>``` and the code is executed, along with all its dependencies. In ROS2, python nodes are also 'compiled' using colcon, but it is but a facade, as it is simply copyinh the code to the build folder to a specific location, among other operations inside the ROS2 environment.

### C++

Compiling a program: ```g++ <program>```

This will originate a file named **a.out** by default, which is the binary. To execute it: ```./a.out```.

This seems fairly simple for a single file program. However, in contrast with python, when your program imports code from another file, the compiler should be notified via flags. In a complex environment, writing commands for compilation becomes a nightmare. For that reason, build systems were born. For instance, **Makefile** is a simple build system which follows a specific yet simple language do define the way a program is compiled, like a recipe for compilation. After that, only run ```make``` to compile and its done. You can find a simple video on Makefiles [here](https://www.youtube.com/watch?v=_r7i5X0rXJk). To install make: ```sudo apt install make```.

#### CMake

For very complex programs, even Makefile started becoming confused. This does sound like a russian doll but CMake was created as a tool to generate automatically Makefiles through simpler language. ROS2 uses CMake for generating Makefiles. Here is an example of a CMakeLists.txt file generated by ROS2, which defines the dependencies of a package and how it should be compiled.

```cmake
cmake_minimum_required(VERSION 3.8)
project(loc_map)

# Flags
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies (libraries and other packages)
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(Eigen3 REQUIRED)
find_package(std_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(custom_interfaces REQUIRED)
find_package(eufs_msgs REQUIRED)
find_package(fs_msgs REQUIRED)

# List Executables
set(IMPLEMENTATION_FILES 
  src/loc_map/lm_node.cpp
  src/kalman_filter/ekf.cpp
  src/kalman_filter/motion_models.cpp
  src/kalman_filter/observation_models.cpp
  src/utils/position.cpp
  src/utils/formulas.cpp
  src/utils/color.cpp
  src/adapter/adapter.cpp
)

add_executable(${PROJECT_NAME} src/loc_map.cpp ${IMPLEMENTATION_FILES}) # Add them all at once
ament_target_dependencies(${PROJECT_NAME} rclcpp std_msgs sensor_msgs eufs_msgs fs_msgs custom_interfaces Eigen3) # Define dependencies again
target_include_directories(${PROJECT_NAME} PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>) # Directories to look for code
target_compile_features(loc_map PUBLIC c_std_99 cxx_std_17) # C++ coding standards

install(TARGETS loc_map
  DESTINATION lib/${PROJECT_NAME})

if(BUILD_TESTING) # Same deal but for testing
  find_package(ament_lint_auto REQUIRED)
  find_package(ament_cmake_gtest REQUIRED)
  find_package(custom_interfaces REQUIRED)
  find_package(rclcpp REQUIRED)
  find_package(sensor_msgs REQUIRED)
  find_package(eufs_msgs REQUIRED)
  find_package(rclcpp REQUIRED)
  find_package(Eigen3 REQUIRED)
  find_package(std_msgs REQUIRED)
  find_package(fs_msgs REQUIRED)

  set(TESTFILES 
    test/main.cpp
    test/integration_test.cpp
    test/ekf_steps_exec_time.cpp
    test/motion_model_test.cpp
    test/observation_model_test.cpp
    test/slam_test.cpp
  )
  
  include_directories(test)  # Include the 'test' directory for your test targets
  include_directories(${CMAKE_CURRENT_SOURCE_DIR})  # Include the current source directory
  ament_add_gtest(${PROJECT_NAME}_test ${TESTFILES} ${IMPLEMENTATION_FILES})
  ament_target_dependencies(${PROJECT_NAME}_test rclcpp std_msgs eufs_msgs sensor_msgs fs_msgs custom_interfaces)
  target_include_directories(${PROJECT_NAME}_test PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>)

  install(TARGETS ${PROJECT_NAME}_test DESTINATION lib/${PROJECT_NAME})
endif()

ament_package()
```

No need to know everything, just the basics and where to tinker to add new files and dependencies. 

The basics:
- inside the ```if(BUILD_TESTING)``` statement, it is only for the unit tests and testing
- all .cpp files used need to be listed and included in the add_executable
- you can create macros like *IMPLEMENTATION_FILES* to ease the reading of the file
- *include_directories* and *targe_include_directories*
- when a new library or ros package is used in this one, add it in *ament_target_dependencies* and add a *find_package* line for it, on top of editing the package.xml (for ROS2) 

More information can be found in [this video](https://www.youtube.com/watch?v=ffwB60oKr-w&list=PL8i3OhJb4FNV10aIZ8oF0AA46HgA2ed8g).

## Coding

### Coding Guidelines

Check out the [coding guidelines](https://www.notion.so/Coding-Guidelines-564735a2da2b4e768db134b889f3dff2?pvs=4) in the rules.

### C++

Recommended:
- [C++ Complete Tutorials](https://www.youtube.com/watch?v=18c3MTX0PK0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb)

### Python

[This one](https://www.youtube.com/watch?v=_uQrJ0TkZlc) or any other of the 1000 tutorials available online (Python is easy).
